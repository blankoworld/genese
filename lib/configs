#!/usr/bin/env bash
#
# This library dependencies:
# - common
# - docker
# - git

#####
## VARIABLES
###

# Default configuration to create instances
CONFIG="${CONFIG:-default}"

# Directory in which instances will be installed
INSTANCES_DIR="${INSTANCES_DIR:-${BASE_DIR}/instances}"
# Directory where to find configs
CONFIGS_DIR="${CONFIGS_DIR:-${BASE_DIR}/configs.example}"
# Instance installation directory (either for creation or deletion).
# Initialized when needed.
INSTALL_DIR=""

# List of services found
SERVICES_LIST=()

# Name of different pre/post triggers, build, etc.
PRE_DOCKER_HOOK_NAME="${PRE_DOCKER_HOOK_NAME:-hook_pre_docker.sh}"
POST_DOCKER_HOOK_NAME="${POST_DOCKER_HOOK_NAME:-hook_post_docker.sh}"

# Name of file containing the repository information to download
REPO_FILENAME="${REPO_FILENAME:-repo}"

# 'extras' directory name containing files to copy as is in install dir
EXTRAS_DIRNAME="${EXTRAS_DIRNAME:-extras}"

# Error messages
ERR_400="The INSTALL_DIR variable is empty."

####
## FUNCTIONS
###

# Discover associated services in the provided file
# Recursive function
# 1: Configuration filename in CONFIGS_DIR folder
discover_services() {
  filepath="${CONFIGS_DIR}/${1}.sh"

  # Interruption if configuration not found.
  if [[ ! -f "${filepath}" ]]; then
    debug_msg "${filepath}"
    err_msg_and_exit "'${1}' config. not found!"
  fi

  # Load data provided in file
  source "${filepath}"

  # Recording of services provided if variable exists
  if [[ -n "${SERVICES}" ]]; then
    # loading table
    multi_services="${SERVICES[@]}"

    # As we are in a recursive, we interruppt the process by deleting SERVICES
    unset SERVICES

    # Keep in memory services list
    for service in "${multi_services[@]}"; do
      SERVICES_LIST+=( "${service}" )
    done

  fi

  # Config. files can have a parent config.
  if [[ -n "${PARENT}" ]]; then
    # loading parent file
    parent_config="${PARENT}"
    unset PARENT

    # Fetch parent ' services
    discover_services "${parent_config}"
  fi
}

# For each service: runs the given script (given as a parameter)
# 1: script filename to run for each service
run_services_script() {
  if [[ -n "${1}" ]]; then
    for service in ${SERVICES_LIST[@]}; do
      local filepath="${REP_SERVICES}/${service}/${1}"
      script_exec "${filepath}" "${service} service: run '${1}' script"
    done
  fi
}

# Extract information from repository filename and download it
# 1: service name
load_service_repo() {
  # If no installation directory given: return an error
  if [[ -z "${INSTALL_DIR}" ]]; then
    err_msg_and_exit "${ERR_400}"
  fi

  # variable initialization
  local service="${1}"
  local filepath="${REP_SERVICES}/${service}/${REPO_FILENAME}"
  local target_dir="${INSTALL_DIR}/${service}"

  # Chargement des informations si le fichier existe
  if [[ -f "${filepath}" ]]; then
    local branch=$(cat "${filepath}"|cut -d ' ' -f 1)
    local address=$(cat "${filepath}"|cut -d ' ' -f 2-)

    # Check branch to load (serviceName_BRANCH override this value)
    local variable=$(echo "${service^^}_BRANCH"|tr '[:lower:]' '[:upper:]'|sed -e 's/-/_/g')
    branch="${!variable:-${branch}}"

    git_clone "${address}" "${branch}" "${target_dir}"
  fi
}

# Loads files from each service into the installation directory
# This is done in several stages:
# 1/ first we clone each service Git repository
# 2/ then we load extra folder by overriding existing files/directories
# (As we would apply a patch)
load_services_files() {
  # Return an error if the install. directory is not given
  if [[ -z "${INSTALL_DIR}" ]]; then
    err_msg_and_exit "${ERR_400}"
  fi

  # 1/ Clone each service git repository (only if repo file exists)
  for service in ${SERVICES_LIST[@]}; do
    load_service_repo "${service}"
  done

  # 2/ Override instance files with 'extras' directory
  for service in ${SERVICES_LIST[@]}; do
    copy_extras_dir "${service}"
  done
}

# Copy all files from 'extras' directory into install. dir (base_dir).
# 1: service from which copy extras directory
copy_extras_dir() {
  local origin="${REP_SERVICES}/${service}/${EXTRAS_DIRNAME}"

  if [[ -d "${origin}" ]]; then
    info_msg "${service}: Copy 'extras' directory content"
    # On ajoute une étoile après les guillemets pour prendre tous les fichiers
    cp -r "${origin}/"* "${INSTALL_DIR}/"
  fi
}

# List of configs available as a basis for instances
list_configs() {
  detection=false

  info_msg "Configs list"

  for config in `find "${CONFIGS_DIR}" -type f -name "*.sh" -printf "%f\n"`; do
    # Exclude common config.
    if [[ "${config}" != "common.sh" ]]; then
      msg "  - ${config/.sh/}"
      detection=true
    fi
  done

  if ! ${detection}; then
    warning_msg "No config. found."
  fi
}

# Listing des services trouvés
list_services() {
  for service in ${SERVICES_LIST[@]}; do
    info_msg "Service: ${service}"
  done
}


# Process config. loading
# 1: Name of configuration file located in CONFIG_DIR folder
load_config() {
  discover_services "${1}"
  list_services
}

# Create an instance from the config. given in argument
# 1: Config. name located in CONFIGS_DIR folder
# Several steps would be executed:
# - create a directory for the instance if needed
# - TODO: stop prevous containers
# - docker-compose.yml file creation
# - installation of files needed for the instance
# - TODO: execute the hook before Docker build command
# - TODO: launch Docker build (to eventually display an error)
# - hook script before Docker containers are launched
# - run containers
# - hook script after Docker containers are ready
create_instance() {
  # Instance installation folder
  INSTALL_DIR="${INSTANCES_DIR}/${1}"

  # Check if directory exists
  if [[ ! -d "${INSTALL_DIR}" ]]; then
    mkdir -p "${INSTALL_DIR}" && success_msg "'${INSTALL_DIR}' directory creation"
  fi

  # TODO: if folder already exists, we should stop containers

  # Initialize instance docker environment (docker-compose.yml, .env)
  creer_espace_docker "${INSTALL_DIR}"

  # Before to run something we load 'extras' files in 
  # instance installation directory
  load_services_files

  # TODO: run docker compose build command
  # TODO: BEFORE docker compose build, we need to execute scripts
  # "pre_docker_build_hook" if exists

  # Run 'pre_docker_hook' script if exists in service directory
  run_services_script "${PRE_DOCKER_HOOK_NAME}"

  # Start docker containers
  demarre_conteneurs "${INSTALL_DIR}"

  # Run 'post_docker_hook' script if exists in service directory
  run_services_script "${POST_DOCKER_HOOK_NAME}"
}

# Lists installed instances
instances_list() {
  detection=false

  if [[ ! -d "${INSTANCES_DIR}" ]]; then
    err_msg_and_exit "Instance folder missing: ${INSTANCES_DIR}"
  fi

  info_msg "Instances list"

  # Folders list in instances directory
  for instance in `ls "${INSTANCES_DIR}"`; do
    filepath="${INSTANCES_DIR}/${instance}/${NOM_FICHIER_DOCKER_COMPOSE}"
    if [[ -f "${filepath}" ]]; then
      msg "  - ${INSTANCES_DIR}/${instance}"
      detection=true
    fi
  done

  if ! ${detection}; then
    warning_msg "No instance found."
  fi
}

# Delete given instance
# 1: instance name
delete_instance() {
  INSTALL_DIR="${INSTANCES_DIR}/${1}"

  # Check if instance directory exists
  if [[ ! -d "${INSTALL_DIR}" ]]; then
    err_msg_and_exit "Instance not found: ${1} (in ${INSTALL_DIR} folder)"
  fi

  # User warning to avoid errors
  warning_msg "Are you sure you want to delete ${INSTALL_DIR} instance? (y/N)"
  read reponse

  case "${reponse}" in
    y|Y)
      info_msg "Deleting: ${INSTALL_DIR}"

      # Extinction of possible started containers
      suppression_conteneurs "${INSTALL_DIR}"

      # Delete instance
      rm -rf "${INSTALL_DIR}"

      success_msg "Instance deleted: ${1} (in ${INSTALL_DIR} folder)"
      ;;
    *)
      info_msg "No instance deleted."
      ;;
  esac
}

#####
## TESTS
###

# We need configs. directory
if [[ ! -d "${CONFIGS_DIR}" ]]; then
  err_msg_and_exit "Folder missing: ${CONFIGS_DIR}"
fi

# Create instances directory if it doesn't exist
if [[ ! -d "${INSTANCES_DIR}" ]]; then
  mkdir -p "${INSTANCES_DIR}"
fi

# vim: ts=2 sw=2 et nu syn=bash
