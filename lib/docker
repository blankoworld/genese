#!/usr/bin/env bash
#
# Lib dependencies:
# - common

#####
## VARIABLES
###

# Final Docker Compose filename (for the instance)
DOCKER_COMPOSE_FILENAME="${DOCKER_COMPOSE_FILENAME:-docker-compose.yml}"
# Final Docker compose file header absolute path
DOCKER_COMPOSE_HEADER_PATH="${TEMPLATES_DIR}/header.yml"
# Common Docker error message
DOCKER_ERR_MSG="Docker problem"
# Docker socket address
DOCKER_SOCKET="${DOCKER_SOCKET:-/var/run/docker.sock}"

# docker-compose.yml filepath. This variable is needed for different
# script to .access it.
DOCKER_COMPOSE_FILEPATH=""

# DOCKER command
DOCKER_CMD=""
# Docker Compose command
DOCKER_COMPOSE_CMD=""

#####
## FUNCTIONS
###

# Checking the Docker command:
# - either podman
# - or docker
docker_ispresent() {
  for cmd in podman docker; do
    if [[ `which ${cmd} &> /dev/null; echo $?` == 0 ]]; then
      export DOCKER_CMD=`which ${cmd}`
      break
    fi
  done
  if [[ -z "${DOCKER_CMD}" ]]; then
    err_msg_and_exit "DOCKER command: not found!"
  fi
}

# Checking the Docker compose command.
# Based on previous DOCKER_CMD variable.
docker_compose_ispresent() {
  # add "-compose" to DOCKER_CMD (podman-compose or docker-compose)
  compose_cmd="${DOCKER_CMD}-compose"
  if [[ `${compose_cmd} &> /dev/null; echo $?` == 0 ]]; then
    export DOCKER_COMPOSE_CMD="${compose_cmd}"
  else
    # TODO: redraft code with `docker info -f '{{json .ClientInfo.Plugins}}'`
    compose_cmd="${DOCKER_CMD} compose"
    ${compose_cmd} version &> /dev/null && export DOCKER_COMPOSE_CMD="${compose_cmd}"
  fi
  if [[ -z "${DOCKER_COMPOSE_CMD}" ]];  then
    err_msg_and_exit "DOCKER COMPOSE command not found!"
  fi
}

# Check Docker service is launched.
docker_service_islaunched() {
  $DOCKER_CMD info &> /dev/null \
    && success_msg "DOCKER: present and launched!" \
    || err_msg_and_exit "DOCKER is missing! Check that it is present and launched."
}

# docker-compose.yml filepath global variable initialization
# 1: Directory in which docker-compose.yml file exists
docker_compose_filepath_variable_init() {
  # Content is only created for the variable if it has never been filled
  if [[ -z "${DOCKER_COMPOSE_FILEPATH}" ]]; then
    local start_filepath=""
    if [[ -n "${1}" ]]; then
      start_filepath="${1}/"
    fi
    DOCKER_COMPOSE_FILEPATH="${start_filepath}${DOCKER_COMPOSE_FILENAME}"
  fi
}

# Create Docker environment in the given directory (argument 1)
# 1: directory where to install docker-compose.yml and .env file
create_docker_env() {
  local dest="${1}"

  # docker-compose.yml file creation
  create_docker_compose_file "${dest}"

  # env file creation in the installation directory
  create_env_file "${dest}"
}

# Create docker-compose.yml file in the given directory
# 1: directory where to create docker-compose.yml file
create_docker_compose_file() {

  # Check argument 1:
  # - if given (mandatory)
  # - if directory exists
  if [[ -z "${1}" ]]; then
    err_msg_and_exit "No directory given"
  elif [[ ! -d "${1}" ]]; then
    err_msg_and_exit "Directory not found: ${1}"
  fi

  docker_compose_filepath_variable_init "${1}"

  # Final docker compose header filepath
  cat "${DOCKER_COMPOSE_HEADER_PATH}" > "${DOCKER_COMPOSE_FILEPATH}"

  # concatenate each service in the docker-compose.yml file
  for service in ${SERVICES_LIST[@]}; do
    service_filepath="${SERVICES_DIR}/${service}/${SERVICE_FILENAME}"

    # Check if service description file exists
    if [[ ! -f "${service_filepath}" ]]; then
      err_msg_and_exit "${service_filepath} file doesn't exist!"
    fi

    # concatenate current content with final docker-compose.yml file
    cat "${service_filepath}"|sed -e 's#^#  #g' >> "${DOCKER_COMPOSE_FILEPATH}"
  done

  success_msg "Docker Compose file: ${DOCKER_COMPOSE_FILEPATH}"
}

# Creating a .env file in the given directory as parameter
# 1: directory in which to install .env file
create_env_file() {
  if [[ ! -d "${1}" ]]; then
    err_msg_and_exit ".env file creation: '${1}' destination not available."
  fi

  local dest="${1}"
  local env_filepath="${dest}/.env"

  info_msg ".env file: keep in memory needed environment variables."

  # Using the username as a prefix,
  # then add directory installation name (supposely uniqueâ€¦)
  # Characters replacement: '/' in '-'
  COMPOSE_PROJECT_NAME=`echo "${USER/./-}-${INSTALL_DIR##*/}" \
    |sed -e 's|/|-|g' \
    -e 's|\.|-|'`

  # Create the .env file
  echo "# File generated by ${PROGRAM}" > "${env_filepath}"
  echo "SERVICES_DIR=\"${SERVICES_DIR}\"" >> "${env_filepath}"
  echo "INSTALL_DIR=\"${INSTALL_DIR}\"" >> "${env_filepath}"
  echo "DOCKER_SOCKET=\"${DOCKER_SOCKET}\"" >> "${env_filepath}"
  echo "COMPOSE_PROJECT_NAME=\"${COMPOSE_PROJECT_NAME}\"" >> "${env_filepath}"

  # All '_PORT' are also added (in case we change ports)
  # If no script output, return a status to 0.
  printenv|grep -E ".*_PORT$" >> "${env_filepath}" || :
}

# Test if Docker Compose file exists, otherwise returns an error
# 1: Docker Compose file
compose_file_ispresent() {
  filepath="${1}"

  if [[ -z "${filepath}" ]]; then
    err_msg_and_exit "No Docker Compose file provided."
  fi

  if [[ ! -f "${filepath}" ]]; then
    err_msg_and_exit "Docker Compose file not found: ${filepath}"
  fi
}

# Starts containers related to the given folder (that contains a docker-compose.yml file)
# 1: Directory in which the docker-compose.yml file is located
start_containers() {

  docker_compose_filepath_variable_init "${1}"
  compose_file_ispresent "${DOCKER_COMPOSE_FILEPATH}"
  docker_service_islaunched

  # Starts containers
  info_msg "Starting Docker Containers"
  ${DOCKER_COMPOSE_CMD} -f "${DOCKER_COMPOSE_FILEPATH}" up -d || err_msg_and_exit \
    "${DOCKER_ERR_MSG}"

  success_msg "Docker Containers launched"
}

# List of containers related to the given folder (that contains a docker-compose.yml file)
# 1: Directory in which the docker-compose.yml file is located
list_containers() {

  docker_compose_filepath_variable_init "${1}"
  compose_file_ispresent "${DOCKER_COMPOSE_FILEPATH}"
  docker_service_islaunched

  # Containers list
  info_msg "Launched Docker containers"
  ${DOCKER_COMPOSE_CMD} -f "${DOCKER_COMPOSE_FILEPATH}" ps || err_msg_and_exit \
    "${DOCKER_ERR_MSG}"
}

# Delete containers linked to the given folder (that contains a docker-compose.yml file)
# 1: Directory in which the docker-compose.yml file is located
delete_containers() {

  docker_compose_filepath_variable_init "${1}"
  compose_file_ispresent "${DOCKER_COMPOSE_FILEPATH}"
  docker_service_islaunched

  # Stopping Docker Containers
  ${DOCKER_COMPOSE_CMD} -f "${DOCKER_COMPOSE_FILEPATH}" kill || err_msg_and_exit \
    "${DOCKER_ERR_MSG}"
  # Containers deletion
  ${DOCKER_COMPOSE_CMD} -f "${DOCKER_COMPOSE_FILEPATH}" down || err_msg_and_exit \
    "${DOCKER_ERR_MSG}"

  success_msg "Docker Containers stopped"
}

#####
## TESTS
###

docker_ispresent
docker_compose_ispresent

# vim: ts=2 sw=2 et nu syn=bash