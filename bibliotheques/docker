#!/usr/bin/env bash
#
# Dépendance de cette bibliothèque : 
# - commun

#####
## VARIABLES
###

# Nom du fichier Docker Compose final (pour l'instance)
NOM_FICHIER_DOCKER_COMPOSE="${NOM_FICHIER_DOCKER_COMPOSE:-docker-compose.yml}"
# Adresse de l'entête utilisée pour le fichier Docker Compose final
ENTETE_DOCKER_COMPOSE="${REP_MODELES}/entete.yml"
# Message d'erreur commun aux problèmes Docker
MSG_ERR_DOCKER="Souci avec Docker"
# Adresse du socket Docker
SOCKET_DOCKER="${SOCKET_DOCKER:-/var/run/docker.sock}"

# Adresse du fichier docker-compose.yml. Cette variable est nécessaire pour
# permettre aux multiples scripts des différents scripts d'y accéder.
FICHIER_DOCKER_COMPOSE=""

# Commande DOCKER
CMD_DOCKER="${CMD_DOCKER:-/usr/bin/docker}"
# Commande Docker Compose
CMD_DOCKER_COMPOSE="${CMD_DOCKER_COMPOSE:-/usr/bin/docker-compose}"

# TEST au plus tôt pour vérifier la présence des éléments Docker
# En cas d'absence, cela permet d'arrêter le programme rapidement
# On teste la valeur fourni par l'utilisateur, sinon le programme par défaut
# Puis on tente podman
# Puis on tente docker
cmd_retenue=false
for cmd in "${CMD_DOCKER}" podman docker; do
  test_commande_presente "CMD_DOCKER" "${cmd}"
  res_cmd=`echo $?`
  if test "${res_cmd}" != 0; then
    continue
  fi
  cmd_retenue="${cmd}"
  msg_info "Commande DOCKER utilisée : ${CMD_DOCKER}"
  break
done
# ERREUR si la commande n'est finalement pas trouvée
if ! test -n $(command -v "${CMD_DOCKER}" &> /dev/null); then
  msg_erreur_exit "Commande DOCKER : non trouvée !"
fi

# TODO: prendre l'action de l'utilisateur en compte
# TODO: améliorer la détection de docker compose
# TEST sur podman-compose/docker-compose avec ou sans espace.
# On s'appuie sur la commande précédente retenue en ajoutant "-compose"
cmd_compose="${cmd_retenue}-compose" # podman-compose ou docker-compose
test_commande_presente "CMD_DOCKER_COMPOSE" "${cmd_compose}"
if test "$?" != 0; then
  echo "COMPOSE : ${cmd_compose} pas TROUVÉE !"
else
  cmd_compose="${cmd_retenue} compose"
  export CMD_DOCKER_COMPOSE="${cmd_compose}"
fi
# ERREUR si la commande n'est finalement pas existante/fonctionnelle
${CMD_DOCKER_COMPOSE} version &> /dev/null \
  && msg_info "Commande DOCKER COMPOSE utilisée : ${CMD_DOCKER_COMPOSE}" \
  || msg_erreur_exit "Commande DOCKER COMPOSE : non trouvée !"

#####
## FONCTIONS
###

# Vérification du service Docker
test_service_docker_en_execution() {
  $CMD_DOCKER info &> /dev/null \
    && msg_succes "DOCKER : présent et lancé !" \
    || msg_erreur_exit "DOCKER : manquant ! Vérifiez qu'il soit présent et lancé."
}

# Initialisation de la variable globale contenant l'adresse du fichier
# docker-compose.yml
# 1: Répertoire duquel construire la variable
initialisation_variable_docker_compose() {
  # On ne créé du contenu pour la variable que si elle n'a jamais été remplie.
  if [[ -z "${FICHIER_DOCKER_COMPOSE}" ]]; then
    local debut_adresse=""
    if [[ -n "${1}" ]]; then
      debut_adresse="${1}/"
    fi
    FICHIER_DOCKER_COMPOSE="${debut_adresse}${NOM_FICHIER_DOCKER_COMPOSE}"
  fi
}

# Création de l'espace Docker dans le répertoire donné en argument
# 1: répertoire où installer le fichier docker-compose.yml et .env
creer_espace_docker() {
  local destination="${1}"

  # Création du fichier docker-compose.yml
  creer_fichier_docker_compose "${destination}"

  # Création du fichier d'environnement dans le répertoire d'installation
  creer_fichier_env "${destination}"
}

# Création du fichier docker-compose.yml dans le dossier donné
# 1: Répertoire dans lequel créer le fichier docker-compose.yml
creer_fichier_docker_compose() {

  # contrôle du répertoire
  if [[ -z "${1}" ]]; then
    msg_erreur_exit "Aucun répertoire donné"
  elif [[ ! -d "${1}" ]]; then
    msg_erreur_exit "Répertoire non trouvé : ${1}"
  fi

  initialisation_variable_docker_compose "${1}"

  # entête du fichier final
  cat "${ENTETE_DOCKER_COMPOSE}" > "${FICHIER_DOCKER_COMPOSE}"

  # ajout de chacun des services
  for service in ${LISTE_SERVICES[@]}; do
    fichier_service="${REP_SERVICES}/${service}/${NOM_FICHIER_SERVICE}"

    # contrôle existance du fichier de description du service
    if [[ ! -f "${fichier_service}" ]]; then
      msg_erreur_exit "Le fichier ${fichier_service} n'existe pas !"
    fi

    # concaténation du contenu avec le fichier final
    cat "${fichier_service}"|sed -e 's#^#  #g' >> "${FICHIER_DOCKER_COMPOSE}"
  done

  msg_succes "Fichier Docker Compose: ${FICHIER_DOCKER_COMPOSE}"
}

# Création d'un fichier .env dans le répertoire donné en paramètre
# 1: Répertoire d'installation du fichier .env
creer_fichier_env() {
  if [[ ! -d "${1}" ]]; then
    msg_erreur_exit "Création d'un fichier .env : Destination '${1}' inexistante."
  fi

  local destination="${1}"
  local fichier_env="${destination}/.env"

  msg_info ".env : mémorisation des variables d'environnement nécessaires."

  # Utilisation du nom de l'utilisateur comme préfixe,
  # agrémenté du nom du répertoire d'installation (qui est censé être unique…)
  # Remplacement des caractères '/' en '-'
  COMPOSE_PROJECT_NAME=`echo "${USER}-${REP_INSTALLATION##*/}" |sed -e 's|/|-|g'`

  # Création du fichier
  echo "# Fichier généré par ${PROGRAMME}" > "${fichier_env}"
  echo "REP_SERVICES=\"${REP_SERVICES}\"" >> "${fichier_env}"
  echo "REP_INSTALLATION=\"${REP_INSTALLATION}\"" >> "${fichier_env}"
  echo "SOCKET_DOCKER=\"${SOCKET_DOCKER}\"" >> "${fichier_env}"
  echo "COMPOSE_PROJECT_NAME=\"${COMPOSE_PROJECT_NAME}\"" >> "${fichier_env}"

  # Tous les "PORT_" s'ajoutent aussi (au cas où nous changeons des ports)
  # Si pas de sortie de script, on retourne un statut à 0.
  printenv|grep -E "^PORT_.*" >> "${fichier_env}" || :
}

# Test si le fichier Docker Compose existe, sinon retourne une erreur
# 1: Fichier Docker Compose
test_existence_fichier_compose() {
  fichier="${1}"

  if [[ -z "${fichier}" ]]; then
    msg_erreur_exit "Aucun fichier Docker Compose fourni."
  fi

  # Si le fichier n'existe pas, on s'arrête !
  if [[ ! -f "${fichier}" ]]; then
    msg_erreur_exit "Fichier Docker Compose non trouvé : ${fichier}"
  fi
}

# Démarrage des conteneurs liés au dossier donné (contenant un fichier
# docker-compose.yml)
# 1: Répertoire dans lequel se trouve le fichier docker-compose.yml
demarre_conteneurs() {

  initialisation_variable_docker_compose "${1}"

  # Vérification que le fichier Docker Compose existe
  test_existence_fichier_compose "${FICHIER_DOCKER_COMPOSE}"
  # Vérification que Docker est bel et bien lancé
  test_service_docker_en_execution

  # Démarrage des conteneurs
  msg_info "Démarrage des conteneurs Docker"
  ${CMD_DOCKER_COMPOSE} -f "${FICHIER_DOCKER_COMPOSE}" up -d || msg_erreur_exit \
    "${MSG_ERR_DOCKER}"

  msg_succes "Conteneurs Docker lancés"
}

# Liste des conteneurs liés au dossier donné (contenant un fichier
# docker-compose.yml)
# 1: Répertoire dans lequel se trouve le fichier docker-compose.yml
lister_conteneurs() {

  initialisation_variable_docker_compose "${1}"

  # Vérification que le fichier Docker Compose existe
  test_existence_fichier_compose "${FICHIER_DOCKER_COMPOSE}"
  # Vérification que Docker est bel et bien lancé
  test_service_docker_en_execution

  # Liste des conteneurs
  msg_info "Liste des conteneurs Docker lancés"
  ${CMD_DOCKER_COMPOSE} -f "${FICHIER_DOCKER_COMPOSE}" ps || msg_erreur_exit \
    "${MSG_ERR_DOCKER}"
}

# Suppression des conteneurs liés au dossier donné (contenant un fichier
# docker-compose.yml)
# 1: Répertoire dans lequel se trouve le fichier docker-compose.yml
suppression_conteneurs() {

  initialisation_variable_docker_compose "${1}"

  # Vérification que le fichier Docker Compose existe
  test_existence_fichier_compose "${FICHIER_DOCKER_COMPOSE}"
  # Vérification que Docker est bel et bien lancé
  test_service_docker_en_execution

  # Arrêt des conteneurs Docker
  ${CMD_DOCKER_COMPOSE} -f "${FICHIER_DOCKER_COMPOSE}" kill || msg_erreur_exit \
    "${MSG_ERR_DOCKER}"
  # Suppression des conteneurs
  ${CMD_DOCKER_COMPOSE} -f "${FICHIER_DOCKER_COMPOSE}" down || msg_erreur_exit \
    "${MSG_ERR_DOCKER}"

  msg_succes "Arrêt des conteneurs Docker"
}

# vim: ts=2 sw=2 et nu syn=bash
