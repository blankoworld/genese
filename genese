#!/usr/bin/env bash
#
# genese: Outil pour générer des instances d'un à plusieurs projets via
#   Docker Compose en utilisant des configs pour savoir quels services
#   utiliser.
#

PROGRAMME=`basename $0 .sh`
BASE_DIR=$(cd `dirname $0` && pwd)

#####
## VARIABLES
###

# Dépôt d'origine à télécharger
SOURCE="https://github.com/blankoworld/genese.git"

# Message d'utilisation du programme
read -d '' UTILISATION << EOF
Utilisation : ${PROGRAMME} [options]

OPTIONS
  -h, --help                  Affichage de l'aide contextuelle
  -i, --instance              Liste des instances installées
  -l, --liste                 Liste des configs disponibles
  -n <nom>, --nom <nom>       Nom de l'instance à créer (s'utilise avec -c)
  -c <nom>, --config <nom>    Utilisation de la config donnée
  -s <nom>, --supprime <nom>  Suppression de l'instance donnée

EXEMPLES

    # Afficher l'aide
    ${PROGRAMME} -h

    # Créer une instance en utilisant la config. 'default'
    ${PROGRAMME} -c default

    # Créer une instance 'super_instance' en utilisant la configuration 'default'
    ${PROGRAMME} -c default -n super_instance

    # Lister les instances ainsi créées
    ${PROGRAMME} -i

    # Supprimer l'instance nommée 'super_instance'
    ${PROGRAMME} -s super_instance

EOF

#####
## FONCTIONS
###

# Affiche l'aide contextuelle
aide() {
 echo -e "${UTILISATION}" 1>&2
}

# Parcours les options de la ligne de commande
analyse_options() {
  # Parcours seulement s'il y a des options
  while [[ "$#" -gt 0 ]]
  do
    case "$1" in
      # Aide contextuelle
      -h | --help)
        aide
        ;;
      -i | --instance)
        instances_list
        ;;
      -l | --liste)
        list_configs
        ;;
      -n | --nom)
        erreur_parametre="Aucun nom d'instance donné pour le paramètre '--nom'."
        if [[ -n "${2}" ]]; then
          # Vérification que l'argument ne démarre pas par un tiret ("-")
          if [[ "${2}" == -* ]]; then
            err_msg_and_exit "${erreur_parametre}"
          fi
          # Initialisation du nom de l'instance (choix fait par l'utilisateur)
          NOM_INSTANCE_CHOISI="${2}"
        else
          err_msg_and_exit "${erreur_parametre}"
        fi
        ;;
      -c | --config)
        if [[ -n "${2}" ]]; then
          CONFIG="${2}"
        fi
        # Marqueur permettant de savoir qu'on souhaite lancer une création d'instance
        CREATION_INSTANCE=true
        ;;
      -s | --supprime)
        if [[ -n "${2}" ]]; then
          # Nom de l'instance à supprimer
          NOM_INSTANCE="${2}"
        else
          err_msg_and_exit "Aucune instance donnée en paramètre !"
        fi
        delete_instance "${NOM_INSTANCE}"
        ;;
    esac
    # Décalage de l'option pour parcourir la suivante
    shift
  done
}

# Charge les données utilisateurs
configure() {
  # Configuration par l'utilisateur ? Si oui, on charge !
  if [[ -f "${BASE_DIR}/.env" ]]; then
    # Charge la liste des variables d'env. personnalisées de l'utilisateur
    source "${BASE_DIR}/.env"
  fi
}

# Affichage du message final après création d'une instance
# - nécessite la bibliothèque 'docker'
# 1: Nom de l'instance
message_post_creation_instance() {
  # Liste des conteneurs de l'instance choisie
  # INSTALL_DIR a été créé dans create_instance
  list_containers "${INSTALL_DIR}"

  # Exécution pour chaque service du fichier 'declencheur_message_final'
  # s'il existe.
  run_services_script "${NOM_DECLENCHEUR_POST_INSTALLATION}"

  # Affichage des infos de portainer
  info_msg "Accès à l'ensemble des 'stacks' installées avec Docker (À METTRE EN FAVORI) : ${BOLD}${RED_COLOR}http://localhost:${PORTAINER_PORT}/${DEFAULT_COLOR}"

  success_msg "Instance '${1}' : Installation terminée."
}

# Essaie de charger le reste des fichiers de ce script en utilisant SOURCE
auto_chargement() {
  # Soit le dépôt GIT existe et on le met à jour,
  local git_rep="${BASE_DIR}/.git"
  if [[ -d "${git_rep}" ]]; then
    cd "${BASE_DIR}" && git pull -q && cd - &>/dev/null
  # soit nous partons du script seul et on télécharge le reste
  else
    # le répertoire de base devient un autre répertoire
    BASE_DIR="${BASE_DIR}/.${PROGRAMME}"
    # En ce cas 2 possibilités : 
    # 1/ le répertoire spécial existe et on met à jour
    # 2/ le répertoire spécial n'existe pas et on clone dedans
    if [[ -d "${BASE_DIR}" ]]; then
      cd "${BASE_DIR}" && git pull && cd - &>/dev/null
    else
      git clone -q "${SOURCE}" "${BASE_DIR}"
    fi
    # Le répertoire de base ayant changé, on recharge la configuration
    configure
  fi
}

#####
## ARGUMENTS
###

# Pas d'argument ? Aide contextuelle et on quitte
[ "$#" -lt 1 ] && aide && exit 1

#####
## TESTS
###

#####
## DÉBUT
###

# charge le fichier de configuration de l'utilisateur
configure
# Avant toute chose on charge le reste de la bibliothèque
auto_chargement

# filename used to describe a service
SERVICE_FILENAME="${SERVICE_FILENAME:-compose.yml}"
# Nom du déclencheur d'affichage des messages après installation
NOM_DECLENCHEUR_POST_INSTALLATION="${NOM_DECLENCHEUR_POST_INSTALLATION:-hook_fin.sh}"

# Chargement des variables dépendantes du répertoire de BASE
# Répertoire dans lequel trouver les services
SERVICES_DIR="${SERVICES_DIR:-${BASE_DIR}/services.example}"
# Répertoire dans lequel trouver les modèles (template) pour un certain
# nombre de fichiers. Volontairement non modifiable par variable d'env.
TEMPLATES_DIR="${BASE_DIR}/templates"

# Load libraries
source "${BASE_DIR}/lib/common"
source "${BASE_DIR}/lib/git"
source "${BASE_DIR}/lib/docker"
source "${BASE_DIR}/lib/portainer"
source "${BASE_DIR}/lib/configs"

# On a besoin du répertoire des services
if [[ ! -d "${SERVICES_DIR}" ]]; then
  err_msg_and_exit "Répertoire manquant : ${SERVICES_DIR}"
fi

# Nom de l'instance à utiliser
NOM_INSTANCE=""
# Nom choisi par l'utilisateur pour une instance
NOM_INSTANCE_CHOISI=""
# À défaut, pas de création d'instance
CREATION_INSTANCE=false

# Parcours des options
analyse_options $@

# Cas de la création d'une instance
if "${CREATION_INSTANCE}"; then
  load_config "${CONFIG}"
  NOM_INSTANCE="${NOM_INSTANCE_CHOISI:-$CONFIG}"
  create_instance "${NOM_INSTANCE}"
  # Traitement post-installation
  lancer_portainer
  # Affichage du message final d'installation pour l'instance choisie
  message_post_creation_instance "${NOM_INSTANCE}"
elif [[ -n "${NOM_INSTANCE_CHOISI}" ]]; then
  # Cas où l'utilisateur a donné le nom d'une instance, sans demander
  # la création d'une instance
  err_msg_and_exit "Nom d'instance: '${NOM_INSTANCE_CHOISI}', mais aucune configuration donnée. Faites '${PROGRAMME} -l' pour lister les configs existantes."
fi

#####
## FIN
###

exit 0
# vim: ts=2 sw=2 et nu syn=bash
